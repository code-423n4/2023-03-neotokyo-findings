# [L-01] Function `_stringEquals` from `NeoTokyoStaker.sol` may return `false` for identical strings

`_stringEquals` iterates through two strings if their lengths are equal and compares `32`-byte chunks of both strings in each iteration, assuming that if their length is not divisible by `32`, they are padded with zeroes at the end. This is not always the case.

While it is true for strings shorter than `32` bytes (`solc` generates `push` instruction with the argument padded with zeroes before calling `_stringEquals`), it doesn't have to be true for strings longer than `32` bytes - they are stored alongside with the code and instead of `push`, the `codecopy` instruction is generated by `solc`, that will only copy the string to memory, without touching the area after the string. 

So, if the length of the string is not divisible by `32` and bigger than `32`, the memory after that string (in the last `32`-byte chunk) may not be zeroed out. It may happen since Solidity docs says:

> "*There are some operations in Solidity that need a temporary memory area larger than 64 bytes and therefore will not fit into the scratch space. They will be placed where the free memory points to, but given their short lifetime, the pointer is not updated. The memory may or may not be zeroed out. Because of this, one should not expect the free memory to point to zeroed out memory.*"

## Proof of concept
Consider the following contract:

```solidity
pragma solidity ^0.8.19;

contract StringEqTest
{
    // function `_stringEquals` from the `NeoTokyoStaker` contract
    function _stringEquals (
        string memory _a,
        string memory _b
    ) private pure returns (bool) {
        bytes memory a = bytes(_a);
        bytes memory b = bytes(_b);
        
        // Check equivalence of the two strings by comparing their contents.
        bool equal = true;
        assembly {
            let length := mload(a)
            switch eq(length, mload(b))

            // Proceed to compare string contents if lengths are equal. 
            case 1 {
                let cb := 1

                // Iterate through the strings and compare contents.
                let mc := add(a, 0x20)
                let end := add(mc, length)
                for {
                    let cc := add(b, 0x20)
                } eq(add(lt(mc, end), cb), 2) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {

                    // If any of these checks fails then arrays are not equal.
                    if iszero(eq(mload(mc), mload(cc))) {
                        equal := 0
                        cb := 0
                    }
                }
            }

            // By default the array length is not equal so the strings are not equal.
            default {
                equal := 0
            }
        }
        return equal;
    }

    function test() public pure returns(bool)
    {
        // some operation that does not fit into the scratch space and overwrites memory after the free
        // memory pointer
        assembly
        {
            let pos := mload(0x40)
            mstore(add(pos, 0x40), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
        }
        // compare identical strings and return true if `_stringEquals` returns true
        if (_stringEquals("012345678901234567890123456789012", "012345678901234567890123456789012"))
            return true;
        return false;
    }
}
```

When `test()` is called after deploying the contract, it will return `false` even though `_stringEquals` is called on identical strings.

## Affected code
The `_stringEquals` function is only used at https://github.com/code-423n4/2023-03-neotokyo/blob/dfa5887062e47e2d0c801ef33062d44c09f6f36e/contracts/staking/NeoTokyoStaker.sol#L950-L954
The bug may manifest itself in the `_stakeS1Citizen` function in case the length of the strings being compared exceeds `32` in the future. It may also lead to another hard to spot bugs in the future.

## Recommendation
Make sure to zero out the part of the memory in the last `32`-byte chunk after each string, for instance by using `and` instruction. If only strings with length less than `32` bytes are going to be compared using `_stringEquals` function, remove the `for` loop and check only the first `32`-byte chunk of each string.


**Note**: although `_stringEquals` was not specifically mentioned as an in-scope function, it is private and only used in the `_stakeS1Citizen` function (which is in scope), so, in my opinion, it may be treated as a part of the `_stakeS1Citizen` function.

# [L-02] `_assetTransfer` and `_assetTransferFrom` from `NeoTokyoStaker.sol` don't check for contract existence

Solidity docs says:
> "*The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.*"

It means that both functions will return `true` if the target addresses are misconfigured.

## Exploit scenario
In case of providing the wrong addresses of `S2_CITIZEN` or `LP` in the constructor and initialising the data using `configure*` functions, users may stake assets even if they don't own them. In other words, calls to:
- `_stakeS2Citizen`
- `_stakeLP`
may succeed due to the lack of contract existence check in `_assetTransferFrom`. Similarly, to avoid similar issues, `_assetTransfer` should also implement this check.